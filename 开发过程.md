# DockMinimize 开发过程总结文档

> 本文档详细记录了 DockMinimize 应用从零开始的完整开发过程，包含技术架构、核心实现、踩坑记录与最佳实践。供后续开发者或 AI 助手快速理解项目并避免重复踩坑。

---

## 一、项目概述

**应用名称**：DockMinimize  
**功能定位**：一款 macOS 菜单栏工具，通过监听 Dock 图标点击事件，实现"点击 Dock 图标隐藏和显示窗口"的功能。  
**技术栈**：Swift + SwiftUI + AppKit (Cocoa)  
**最低系统要求**：macOS 12.0+  
**架构类型**：支持 Universal Binary (arm64 + x86_64)

---

## 二、核心架构

### 2.1 文件结构

```
DockMinimize/
├── DockMinimize/                    # Xcode 项目目录
│   ├── DockMinimize.xcodeproj/      # Xcode 工程文件
│   ├── AppDelegate.swift            # 应用生命周期管理
│   ├── MenuBarController.swift      # 菜单栏图标与设置窗口控制
│   ├── SettingsManager.swift        # 设置管理（单例）
│   ├── SettingsView.swift           # SwiftUI 设置界面
│   ├── DockEventMonitor.swift       # Dock 事件监听核心逻辑
│   ├── AccessibilityManager.swift   # 辅助功能权限管理
│   ├── WindowManager.swift          # 窗口操作工具类
│   ├── DebugLogger.swift            # 调试日志工具
│   ├── Info.plist                   # 应用配置
│   ├── AppIcon.icns                 # 应用图标（永久存储）
│   └── Assets.xcassets/             # 资源目录
│       ├── AppIcon.appiconset/      # 应用图标源文件
│       └── MenuBarIcon.imageset/    # 菜单栏图标源文件 (menu.png)
├── build_dmg.sh                     # 当前架构 DMG 打包脚本
├── build_universal_dmg.sh           # 通用架构 DMG 打包脚本
└── DockMinimize.app/                # 编译产物（运行时生成）
```

### 2.2 核心类职责

| 类名 | 职责 |
|------|------|
| `AppDelegate` | 应用入口，初始化 MenuBarController，处理应用重新激活逻辑 |
| `MenuBarController` | 管理菜单栏图标、左键/右键交互、设置窗口的创建与显示 |
| `SettingsManager` | 单例模式，管理所有用户设置（操作模式、语言、开机启动等） |
| `SettingsView` | SwiftUI 视图，提供用户配置界面 |
| `DockEventMonitor` | 核心功能：监听 Dock 图标点击事件并执行相应操作 |
| `AccessibilityManager` | 检查和请求辅助功能权限 |

---

## 三、关键技术实现

### 3.1 菜单栏图标与交互 (MenuBarController)

**核心要点：**

1. **左右键分离**：
   - 左键点击：直接弹出设置面板（居中显示）
   - 右键点击：弹出上下文菜单（设置/退出）
   - 实现方式：通过 `button.sendAction(on: [.leftMouseUp, .rightMouseUp])` 监听不同事件

2. **窗口定位**：
   - 每次显示都调用 `window.center()` 确保居中
   - **禁止**使用 `setFrameAutosaveName`（会导致位置记忆，与预期不符）

3. **图标加载优先级**：
   ```swift
   // 1. 优先从 Resources 加载
   NSImage(contentsOf: Bundle.main.url(forResource: "menu_icon", withExtension: "png"))
   // 2. 其次从 Assets 加载
   NSImage(named: "MenuBarIcon")
   // 3. 兜底使用系统符号
   NSImage(systemSymbolName: "square.3.layers.3d.down.right")
   ```

4. **窗口生命周期**：
   - 设置 `window.isReleasedWhenClosed = false`，确保窗口关闭后不被销毁
   - 这能实现"秒开"效果，避免每次都重新创建窗口

### 3.2 多语言支持 (i18n)

**实现方案**：

```swift
// SettingsManager.swift
enum AppLanguage: String, CaseIterable {
    case english = "en"
    case simplifiedChinese = "zh-Hans"
}

func t(_ zh: String, _ en: String) -> String {
    return language == .simplifiedChinese ? zh : en
}
```

**使用方式**：
```swift
Text(settingsManager.t("设置", "Settings"))
```

**注意事项**：
- 语言切换需要发送通知 `.languageChanged`，菜单栏控制器需监听并刷新菜单
- 默认语言根据系统 `Locale.current.identifier` 自动判断

### 3.3 静默启动与首次启动弹窗

在 `AppDelegate.applicationDidFinishLaunching` 中，通过检查 `UserDefaults` 实现：
```swift
let hasLaunchedBefore = UserDefaults.standard.bool(forKey: "hasLaunchedBefore")
if !hasLaunchedBefore {
    menuBarController?.showSettingsWindow()
    UserDefaults.standard.set(true, forKey: "hasLaunchedBefore")
}
```

这能确保用户在 **首次安装** 打开应用时立即看到设置面板，确认软件已运行；而在后续启动（包括开机自动启动）时，程序将在后台静默运行，不会自动弹出窗口打扰用户。

---

## 四、踩坑记录与解决方案

### 4.1 终端命令执行断连

**问题**：在 M3 Pro 上执行复杂的 Shell 命令链时，终端 PTY 连接频繁断开。

**原因**：
1. 使用 `#` 注释符号在命令行字符串内部会导致 zsh 解析错误
2. 过长的 `&&` 链式命令超过了某些环境的缓冲限制

**解决方案**：
- 拆分命令为多个独立的 `run_command` 调用
- 避免在命令字符串中使用 `#` 注释

### 4.2 图标显示异常

**问题**：应用图标或菜单栏图标不显示、显示透明、或显示旧版本。

**根因**：
1. 图标源文件未正确存入 `Assets.xcassets`
2. `Info.plist` 中 `CFBundleIconFile` 未正确指向 `AppIcon`
3. macOS 系统图标缓存未刷新

**解决方案**：
1. 将图标永久存入项目目录（`DockMinimize/AppIcon.icns` 和 `Assets.xcassets/MenuBarIcon.imageset/menu.png`）
2. 打包脚本中强制注入并执行 `plutil -replace CFBundleIconFile -string AppIcon`
3. 执行 `touch DockMinimize.app` 刷新系统认知

### 4.3 codesign 签名失败

**问题**：`DockMinimize.app: resource fork, Finder information, or similar detritus not allowed`

**原因**：文件包含 macOS 扩展属性（如通过 Finder 复制时附加的元数据）

**解决方案**：
在签名前执行：
```bash
xattr -cr "$APP_NAME.app"
```

### 4.4 设置窗口位置不一致

**问题**：设置面板每次打开位置不同，甚至"满屏乱跑"。

**原因**：
1. 使用了 `setFrameAutosaveName` 导致系统记忆了用户拖动的位置
2. 重复调用 `center()` 的时机不对

**解决方案**：
- 移除 `setFrameAutosaveName`
- 在每次 `showSettingsWindow` 时都调用 `window.center()`

### 4.5 右键菜单显示快捷键

**问题**：右键菜单显示了多余的快捷键提示（如 ⌘Q）

**解决方案**：
将 `keyEquivalent` 设置为空字符串：
```swift
NSMenuItem(title: "退出", action: #selector(NSApplication.terminate(_:)), keyEquivalent: "")
```

---

## 五、打包与发布

### 5.1 打包脚本

项目根目录下有两个打包脚本：

| 脚本 | 用途 |
|------|------|
| `build_dmg.sh` | 快速打包当前架构（适合开发测试） |
| `build_universal_dmg.sh` | 打包通用架构（支持 Intel + Apple Silicon，适合正式发布） |

### 5.2 打包流程关键步骤

1. **编译**：使用 `xcodebuild` 编译 Release 版本
2. **资源注入**：
   - 复制 `AppIcon.icns` 到 `Contents/Resources/`
   - 复制 `menu.png` 到 `Contents/Resources/menu_icon.png`
   - 更新 `Info.plist` 中的图标引用
3. **清理扩展属性**：`xattr -cr DockMinimize.app`
4. **签名**：`codesign --force --deep --sign - DockMinimize.app`
5. **生成 DMG**：使用 `hdiutil` 创建镜像

### 5.3 通用架构编译参数

```bash
xcodebuild ... ARCHS="arm64 x86_64" ONLY_ACTIVE_ARCH=NO
```

---

## 六、设置与权限

### 6.1 辅助功能权限

应用需要辅助功能权限才能监听 Dock 点击事件。

**检查权限**：
```swift
AXIsProcessTrusted()
```

**请求权限**：
```swift
let options = [kAXTrustedCheckOptionPrompt.takeUnretainedValue() as String: true]
AXIsProcessTrustedWithOptions(options as CFDictionary)
```

### 6.2 开机自动启动

使用 `ServiceManagement` 框架：
```swift
import ServiceManagement

// 注册
try SMAppService.mainApp.register()

// 取消注册
try SMAppService.mainApp.unregister()

// 检查状态
SMAppService.mainApp.status == .enabled
```

---

## 七、UI 设计规范

### 7.1 设置面板

- **尺寸**：320 x 460
- **样式**：无标题栏透明、可拖动、始终置顶 (`.floating`)
- **位置**：每次打开都居中显示

### 7.2 菜单栏图标

- **尺寸**：18 x 18 像素
- **格式**：PNG，设置 `isTemplate = true` 以适应深色/浅色模式

### 7.3 右键菜单

- **菜单项**：设置（齿轮图标）、退出（圆圈叉号图标）
- **无快捷键提示**：`keyEquivalent` 设为空

---

## 八、注意事项清单

1. **图标资源必须永久存入项目目录**，不要依赖外部临时文件
2. **菜单栏控制器必须继承 NSObject** 才能使用 `@objc` 方法
3. **窗口 center() 必须在每次显示时调用**，不要使用位置记忆
4. **打包前必须清理扩展属性** (`xattr -cr`)
5. **复杂命令拆分执行**，避免 PTY 断连
6. **语言切换需要发通知**，菜单栏需监听并刷新
7. **仅在首次启动时弹窗**，后续启动应保持静默，避免干扰用户

---

## 九、后续开发建议

1. 如需修改图标，请同时更新 `Assets.xcassets` 和项目根目录的备份文件
2. 如需新增设置项，在 `SettingsManager` 中添加 `@Published` 属性并配置 `UserDefaults` 持久化
3. 如需调整窗口行为，请始终在 `MenuBarController.showSettingsWindow()` 中修改
4. 运行打包脚本前，建议先关闭正在运行的应用实例

---

## 十、悬停预览功能模块 (Hover Preview)

### 10.1 功能概述

在 Dock 图标上悬停时显示窗口预览缩略图，类似 Windows 任务栏的 Hover Preview 功能。

### 10.2 新增文件

| 文件 | 职责 |
|------|------|
| `ScreenCaptureManager.swift` | 屏幕录制权限管理、窗口截图 |
| `WindowThumbnailService.swift` | 获取应用窗口列表、缩略图生成与缓存 |
| `HoverEventMonitor.swift` | 全局 MouseMoved 事件监听、Dock 图标悬停检测 |
| `PreviewStateManager.swift` | 交互状态机（hidden/showing/peeking） |
| `PreviewBarView.swift` | 预览条主视图（SwiftUI） |
| `ThumbnailCardView.swift` | 单个缩略图卡片视图 |
| `PreviewBarController.swift` | 预览条窗口控制器，整合所有模块 |

### 10.3 核心状态机

```
hidden ──(悬停 Dock 0.1s)──> showing ──(悬停缩略图 0.3s)──> peeking
   ^                            │                             │
   └────────(鼠标移出)──────────┴─────────────────────────────┘
```

### 10.4 权限要求

- **辅助功能权限**：用于检测 Dock 图标和控制窗口
- **屏幕录制权限**：用于截取窗口缩略图

### 10.5 用户设置

在设置面板新增：
- 悬停预览开关（默认开启）
- 屏幕录制权限状态显示与授权引导

---

## 十一、 架构大版本迭代：Hover Preview 与状态机模式 (V5.9 - V5.13)

本阶段标志着 DockMinimize 从单一的“点击增强工具”升级为具备“Windows 风格悬停预览”的综合窗口管理软件。

### 11.1 悬停预览 (Hover Preview) 功能实现 (V5.9)

**需求来源**：用户希望在 Dock 图标上悬停 0.1秒后，显示该 App 所有窗口的实时缩略图，并支持水平滚动查看。

**技术实现路径：**
1. **触发逻辑 (`HoverEventMonitor`)**：
   - 监听全局 `kCGEventMouseMoved` 事件。
   - 实现了基于 `AXUIElement` 的 Dock 图标位置与 Bundle ID 提取逻辑。
   - 引入 0.1s 延迟消抖，避免快速划过 Dock 时频繁闪烁。

2. **UI 架构 (`PreviewBarController`)**：
   - 使用 `NSWindow` 创建无边框悬浮窗。
   - 内部嵌入 `SwiftUI` 视图 (`PreviewBarView`)。
   - 实现了水平滚动逻辑：
     - 如果窗口数量少（< 5个），自动居中。
     - 如果窗口数量多，开启水平滚动。
     - 渐变遮罩 (Fade Mask)：在滚动视图边缘添加渐变层，提示用户还有更多内容。

### 11.2 窗口截图 (Snapshot) 技术攻关

**核心挑战**：标准 API `CGWindowListCreateImage` 无法截取 **最小化** 状态的窗口（截取结果为空白或仅有阴影）。

**技术演进**：
1. **尝试一：公共 API**：失败，无法满足需求。
2. **尝试二：参考 DockDoor (开源项目)**：
   - 引入私有 API 桥接头文件 `PrivateApis.swift`。
   - 核心函数：`CGSHWCaptureWindowList` (来自 CoreGraphics 私有符号)。
   - **多级回退策略**：
     - 首选：`[.ignoreGlobalClipShape, .bestResolution]`（最佳质量）。
     - 备选：`[.ignoreGlobalClipShape, .nominalResolution]`（针对部分最小化窗口）。
     - 兜底：无 Flags（最原始截图）。

### 11.3 窗口过滤与匹配逻辑重构 (V5.10)

**痛点解决**：截图 API 返回了大量系统背景层、透明窗口或不可见辅助窗口。

**方案升级**：
1. **引入 DockDoor 过滤算法**：
   - 排除 `kCGWindowLayer != 0` 的非应用层口。
   - 排除 `kCGWindowAlpha == 0` 的完全透明窗口。
   - 排除 `kCGWindowOnScreen == false` 且非最小化的窗口。
2. **精准对象映射**：
   - 重构 `WindowInfo` 结构体，增加 `axElement: AXUIElement` 字段。
   - 使用 `_AXUIElementGetWindow` (私有 API) 将 Accessibility 对象与 CGWindowID 建立强绑定，替代了不可靠的 PID 遍历匹配。

### 11.4 交互体验优化：大图预览与状态机调优 (V5.11 - V5.13)

**交互问题**：用户反馈悬停缩略图时，直接“展开”原窗口体验非常突兀，且容易误操作。
**解决方案**：
1. **引入中心大图预览 (`LargePreviewView`)**：
   - 悬停缩略图时，不再触碰真实窗口。
   - 改为在屏幕中央弹出一个独立的 `LargePreviewWindow`，显示该窗口的高清截图。
2. **点击行为规范化**：
   - **单击展开**：利用保存的 `axElement` 调用系统级 `AXRaise` 动作。
   - **再次点击收回**：利用 `kAXMinimizedAttribute` 实现最小化。

### 11.5 存储架构：CacheManager 的引入

**背景**：为了解决重启后预览图丢失需要重新抓取导致 CPU 飙升的问题。
**方案**：
- 实现 `CacheManager`，将缩略图以 PNG 格式持久化到 `~/Documents/DockMinimize_Cache/`。
- 引入 **第三步权限 ("临时存储")**：在设置面板申请磁盘写入权限，合规访问非沙盒目录。
- **自动维护**：24小时过期清理 + 200MB 容量上限。

---


## 十二、UI 改版：沉浸式侧边栏与系统级质感 (V5.14)

### 12.1 系统级 "Liquid Glass" 效果 (macOS 13+)

**痛点**：原先使用 `.sidebar` material 结合 `HStack` 手写布局，导致侧边栏呈现“磨砂玻璃”效果，与现代 macOS 应用通透的“液态玻璃”质感不符。

**重构方案**：
1. **全面拥抱系统 API**：
   - 移除所有手动 `VisualEffectView` 背景设置。
   - 采用 `NavigationSplitView` + `.listStyle(.sidebar)`。
   - 这让系统能够自动接管侧边栏的材质渲染，完美呈现官方的半透明、通透光影效果。

2. **代码实现**：
   ```swift
   NavigationSplitView {
       List(SettingsTab.allCases, id: \.self, selection: $selectedTab) { ... }
       .navigationSplitViewColumnWidth(min: 180, ideal: 200, max: 220)
       // ...
   } detail: {
       contentView.background(Color(NSColor.windowBackgroundColor))
   }
   ```

### 12.2 视觉排版精修

**尺寸与间距调整：**
- **窗口瘦身**：整体尺寸缩减至 **700 x 480**，更加紧凑精致。
- **内容对齐**：内容页面的顶部 Padding 从 32 缩减至 **12**，确保标题“权限设置”与侧边栏选中项在视觉上水平对齐。
- **侧边栏宽度优化**：
  - 设置 `min: 180`，防止英文标签显示不全。
  - 设置 `max: 220`，防止用户过度拖拽导致布局失衡。

**细节打磨：**
- **退出按钮**：颜色调整为淡红色 (`.red.opacity(0.8)`)，在保持警示的同时不失优雅。
- **对齐修正**：统一常规设置中所有图标容器宽度为 **30px**，解决因图标光栅尺寸不同导致的未对齐问题。
- **左对齐修正**：操作模式下的提示卡片文字强制左对齐，消除居中显示的违和感。

---

## 十三、 深度交互优化与兼容性方案 (V5.15 - V5.18)

本阶段解决了多个长期困扰用户的交互痛点，并引入了“应用黑名单”作为通用兼容性方案。

### 13.1 应用黑名单 (Blacklist) 与 UI 美化 (V5.15)

**背景**：部分特殊应用（如“贴边隐藏”软件、浮动工具栏）与插件的事件拦截机制冲突，导致无法通过点击 Dock 图标正常激活。

**解决方案**：
1. **黑名单机制**：
   - 允许用户手动将特定应用加入黑名单。
   - **全面避让**：对于黑名单应用，插件不仅不拦截事件，而且不生成预览图、不调用任何相关 Accessibility API，实现“彻底透明”。
2. **UI 优化**：
   - **左对齐布局**：将黑名单设置界面的所有元素调整为左对齐，保持软件整体审美一致。
   - **条件化显示**：当黑名单为空时，隐藏中间的列表容器和“暂无记录”提示，仅显示警告文字和添加按钮，视觉效果更清爽。

### 13.2 悬停性能与“丝滑”响应 (V5.16)

**优化点**：
- **瞬发感应**：将 Dock 图标的悬停识别延迟从原先的 50ms 压缩至 **20ms**。
- **效果**：用户在大范围、快速地左右滑动 Dock 栏时，预览条会以“近乎零延迟”的速度紧随鼠标切换，不再有明显的脱节感。

### 13.3 彻底修复“小窗不消失”与“废纸篓冲突” (V5.17)

**Bug 描述**：当鼠标移向废纸篓或从 Dock 边缘滑出到桌面时，预览条会卡在屏幕上不消失；点击桌面也无法强制其关闭。

**解决方案**：
1. **精准区域判定**：移除了模糊的 `inDock` 全区域检查。现在插件会准确判断鼠标是否仍在特定的 App 图标上，一旦滑入“废纸篓”这类不产生预览的区域，立即触发消失。
2. **全局点击监听 (Global Click Monitor)**：
   - 引入系统级监听器：`NSEvent.addGlobalMonitorForEvents`。
   - **兜底策略**：只要用户点击了桌面、浏览器或其他任何非预览区域，预览条会接收到指令强制自我毁灭，绝不留恋。
3. **交互稳定性防护**：
   - 增加了 **Dock 200ms** 和 **预览条 300ms** 的移出缓冲区，防止因快速操作或手抖导致的预览窗闪退。

### 13.4 多窗口“点两次才弹完”的深度根治 (V5.18)

**问题根源**：
- 之前逻辑过于依赖内存缓存（记录谁被最小化了），导致状态识别不准。
- 且在应用处于后台时，将点击权交还给系统 Dock，而系统 Dock 默认往往只弹出第一个窗口。

**核心修复方案**：
1. **实时状态扫描 (Real-time AX Scan)**：
   - 彻底废弃内存缓存。每次点击 Dock 图标时，都会实时扫描该应用的所有窗口。
   - **判定逻辑**：只要有一个窗口是最小化的，点击的目标就是“**一次性恢复所有窗口**”。
2. **全面接管后台点击**：
   - 插件不再放行后台应用的点击。只要应用在运行且不在黑名单中，我们就会拦截点击动作。
   - 手动接管“从背景回前台”的转换过程，确保第一下点击就强制执行 `restoreAllWindows`，实现“一键全开”。

---

## 十四、 性能与稳定性终极闭环优化 (V5.19 - V5.21)

本阶段通过重构底层交互锁机制，彻底解决了单窗口操作的“不丝滑”感以及多窗口操作下的系统级崩溃问题。

### 14.1 单窗口“零拦截”与极限响应 (Zero-Interception)

**痛点**：为了防崩溃引入的 `isTransitioning` 状态锁在单窗口下显得过于臃肿，导致用户快速连点时出现“点击落空”。

**优化方案**：
1. **拦截豁免**：在 `WindowManager` 中调整判定顺序。针对单窗口应用，**直接跳过**拦截检查。
2. **效果**：无论点击多快，哪怕动画在半途中，系统也会立刻响应下一次指令，实现物理级的“无感”交互。
3. **极速释放**：将单窗口的锁定延迟压缩至 **50ms**（仅用于硬件消抖），基本等同于零延迟。

### 14.2 物理级“阶梯锁定”替代脆弱轮询 (Fixed-Time Safety)

**技术重构**：
- **废弃轮询**：彻底删除基于 `AXUIElement` 的画面稳定性监测逻辑。理由是 Finder 等系统 App 在动画中会产生大量“窗口幽灵状态”，导致轮询陷入死锁。
- **阶梯延时策略**：基于窗口数量设定固定的“呼吸时间”：
    - **1 个窗口**：0.05s 解锁。
    - **2-3 个窗口**：0.35s 解锁（精准匹配 macOS 动画时长）。
    - **> 3 个窗口**：0.4s 解锁（隐藏模式专属时间）。
- **收益**：保证了 100% 的响应成功率，彻底杜绝了“图标卡死不响应”的现象。

### 14.3 智能双模切换 (Smart Hybrid Mode)

**核心防御策略**：
- **自动判定**：当检测到同 App 窗口数 **> 3 个** 时，系统会自动从“最小化”转向**“隐藏”模式**。
- **避坑逻辑**：多窗口同时执行最小化动画是 macOS 底层渲染崩溃的高效触发点。隐藏模式瞬间完成且不触发系统缩放动画，从算法层面绕过了崩溃路径。

### 14.4 SwiftUI 渲染稳定性：ViewModel 复用与原子刷新

**崩溃修复**：
- **VM 复用**：如果用户在同一 App 的图标上快速反复悬停，不再重建整个 View 树，而是复用现有的 `ViewModel` 仅更新数据。
- **原子刷新**：在切换不同 App 的预览图时，强制先执行 `window.contentView = nil` 进行彻底卸载，再挂载新视图，防止因视图复用导致的内存竞态崩溃。
- **无条件消失**：修正了 `hidePreviewBar` 的逻辑，确保鼠标一旦移出，预览窗口**无条件**撤离屏幕，不再受窗口锁定状态的影响。

---

**文档版本**：1.8  
**最后更新**：2026-02-04

---

### 十六、 Finder 深度同步与零延迟逻辑优化 (V5.23+)

本阶段解决了 Finder 点击不响应的“顽疾”，并实现了极其精准的点击反馈动画，彻底消除了视觉上的突兀感。

#### 16.1 Finder “首点不响应” Bug 根制

**问题现象**：当 Finder 窗口全部被缩小时，第一次点击 Dock 图标，指示条没反应，只有点第二次才会恢复窗口。

**原因定位**：
- `DockEventMonitor` 在拦截点击时会通过 `CGWindowList` 检查应用是否有“可见窗口”。
- **系统特性**：最小化状态的 Finder 窗口在 `CGWindowList` 中不被视为“Visible”，导致拦截器认为 Finder “无窗口”，从而放手给系统处理。系统 Dock 接收到点击后仅将 Finder 切到前台，却无法触发我们程序的 UI 更新。

**修复方案**：
- **豁免机制**：在 `DockEventMonitor` 中针对 Finder 强制关闭“可见性”过滤。
- **效果**：无论 Finder 是何种状态，只要点一下，程序都会瞬间捕捉并执行 `toggleWindows`，实现 100% 响应。

#### 16.2 确定性锚点切换 (Deterministic Toggle)

**逻辑升级**：
- 废弃了基于全员状态判断的 `allSatisfy` 逻辑。
- **基准锚点**：以“第一个窗口”的状态为唯一基准。如果第一个是灰的，全部变蓝；如果是蓝的，全部变灰。
- **收益**：避免了因后台幽灵窗口导致的操作逻辑“打架”，确保每次点击都有明确、可预期的切换方向。

#### 16.3 精准动画触发：区分 Restore 与 Raise

**设计规范重定向**：
- **还原 (Restore, Grey -> Blue)**：窗口从缩小变展开。**禁止**播放上抬（Bump）动画，保持干脆利落。
- **置顶 (Raise, Blue -> Blue)**：窗口已展开但在后台被挡住。**必须**播放上抬动画，提供明确的视觉反馈告知窗口已置顶。
- **缩小 (Minimize, Blue -> Grey)**：窗口变灰。**禁止**任何上抬动画。

**实现技巧**：
- 在 `handleDockClick` 接收 `action` 时，仅当 `action == "activate"` 且当前窗口状态 `!isMinimized` 时才触发 `bumpTrigger`。

#### 16.4 “毫秒级” UI 先行同步

**优化手段**：
- 将指示条变色的 `Notification` 广播提到 `DockEventMonitor` 的**首行**。
- **无感延迟**：指示条先刷新颜色，程序后执行复杂的系统级 `AXUIElement` 窗口操作（通常耗时 50-200ms）。
- **感受**：用户手指按下的瞬间，指示条立刻变色，消除了“先点完，过一会儿条才变”的肉眼延迟感。

---

### 十七、“原位预览”对齐修复与渲染优化 (V5.24+)

本阶段解决了悬停预览在“原位模式”下的位置偏移、重影以及 Retina 屏幕下的尺寸异常问题。

#### 17.1 座标对齐精度修复

**痛点**：当窗口部分出界时，生成的预览图与原窗口位置无法重合（产生“重影”），且在多屏环境下 Y 轴座标经常发生跳变。

**解决方案**：
1. **统一翻转基准**：抛弃 `NSScreen.main`，统一使用系统主屏幕 (`NSScreen.screens[0]`) 的高度作为全局座标翻转基准，确保在任何显示器配置下 Y 轴计算的一致性。
2. **座标日志监控**：在 `PreviewBarController` 中引入了 `📐` 特征日志，实时打印窗口的 CG 原生座标与转换后的 AppKit 座标，方便像素级排查。

#### 17.2 渲染架构切换：从 SwiftUI 到 Native View

**架构调整**：针对“原位预览”模式，将渲染引擎由 SwiftUI 的 `NSHostingView` 切换回原生的 `NSImageView`。

**原因分析**：
- **SwiftUI 限制**：SwiftUI 的容器在处理尺寸不匹配的图片（如出界产生的残缺截图）时，会自动应用“居中”和“缩放”逻辑，很难实现纯粹的边缘锚定。
- **原生优势**：`NSImageView` 提供更透明的对齐控制。通过设置 `imageAlignment = .alignTopLeft` (默认) 或 `.alignTopRight` (左侧出界时)，可以强制让残缺截图的有效点阵从窗口边缘起算，实现 1:1 动态覆盖。

#### 17.3 Retina 高清屏点阵适配

**问题**：直接使用截图的 Pixel 尺寸作为 `NSImage` 的尺寸，导致在 MacBook 或 4K 屏上预览图比原窗口大一倍。

**修复方案**：
- 在 `ScreenCaptureManager` 中引入 `backingScaleFactor` 检测。
- **公式转换**：`Point Size = Pixel Size / Scale Factor`。
- 确保所有的截图方式（私有/公共 API）均输出 Point 单位的图像，从而在系统中以正确的物理尺寸呈现。

#### 17.4 部署健壮性与系统缓存刷新

**部署过程优化**：
1. **进程管理安全化**：将 `pkill -f` 修正为精确匹配 `pkill -x`，避免因路径名包含项目关键字导致误杀 AI 助手后台服务进程，增强了自动化部署的稳定性。
2. **资源包补完**：解决了分发包中 `AppIcon.icns` 资源丢失的逻辑漏洞。
3. **系统权限图标刷新**：
   - 升级 `CFBundleShortVersionString` 至 `1.0.1` 触发 macOS 资源变更感知。
   - 调用 `lsregister -f` 强制刷新 Launch Services 缓存，彻底解决系统设置权限页面显示空白图标的问题。

---

### 十八、小窗一键关闭与动态容器适配 (Efficiency Boost)

本阶段为预览条引入了“一键关闭”能力，并解决了窗口关闭后外部容器无法自适应缩放的视觉痛点。

#### 18.1 “静默关闭”指令实现

**场景**：用户希望直接在 Dock 预览条上关闭应用窗口，而无需先点击激活应用再按 Cmd+W。

**实现细节**：
1. **指令透传**：利用已捕获的 Accessibility `closeButton` 要素，调用 `AXUIElementPerformAction(closeBtn, kAXPressAction)` 模拟物理点击红色关闭按钮。
2. **状态联动**：通过 `NotificationCenter` 建立 `WindowDidClose` 通知机制。当底层窗口关闭后，UI 框架立即响应，从当前视图模型中移除对应的数据模型，实现实时同步。

#### 18.2 UI 响应式交互增强

**设计方案**：
- **悬停显示**：一键关闭按钮 (`xmark`) 采用“悬停即视”逻辑。仅当鼠标移动到特定小窗预览上时，右上角才会显现灰圈包裹的关闭按钮。
- **防止穿透**：通过 SwiftUI 的 `Button` 事件隔离，确保点击关闭按钮不会触发底层缩略图卡片的“激活应用”动作。

#### 18.3 动态容器收缩与对齐补丁

**痛点**：关闭一个小窗后，外部预览条容器仍保持原有宽度，导致右侧出现大片留白，且整体位置不再对齐图标中心。

**解决方案：Combine 状态驱动布局**：
1. **引入观察者**：在 `PreviewBarController` 中引入 `Combine` 框架，建立对 `viewModel.$lastWindowCount` 的订阅。
2. **实时 Frame 重绘**：当窗口数量减少时，控制器自动重新调用 `calculateWindowSize`。
3. **平滑缩放动画**：应用 `NSAnimationContext` 的 0.2s 平滑过渡，让预览条窗口物理边界伴随内容减少而自动收缩，并重新计算 `Origin` 以维持锚定在 Dock 图标中心。
4. **即时退场**：若最后一个窗口被关闭，逻辑上强制触发 `stateManager.hidePreview()`，确保容器立即淡出而不是留下一条空杠。

### 指示条焦点状态显式化 (Focus-Aware Indicator Differentiation)

为了提升多窗口管理时的直觉反馈，我们对缩略图下方的指示条（蓝色长条）引入了基于“焦点状态”的透明度区分逻辑。

#### 1. 判定逻辑重塑
- **系统级感应**：逻辑不再仅仅比较“应用内谁最前”，而是首先检查应用是否为系统当前的 **Frontmost Application**。
- **状态分级**：
    - **后台应用**：所有指示条统一呈现 **50% 透明度**，表示应用整体处于非活跃状态。
    - **前台应用**：真正的焦点窗口显示为 **100% 不透明蓝色**，其余辅助窗口显示为 **50% 透明度**。
    - **最小化**：维持之前的灰色短条状态。

#### 2. 技术实现细节
- **状态同步机制**：在 `PreviewStateManager` 中新增 `didUpdateActiveWindows` 回调，将精准判定的焦点 ID 实时推送到 `PreviewBarViewModel`。
- **视觉动画增强**：在 `ThumbnailCardView` 中为 `opacity` 属性绑定了平滑的 `easeInOut` 动画，并同步触发轻盈的 **Bump (上抬)** 物理反馈，让状态切换具有“呼吸感”。
- **修复逻辑冲突**：移除了早期版本中在显示预览条时强制标记所有窗口为活跃的冗余代码，确保 UI 严格遵循 Accessibility 接口反馈的真实焦点。

#### 3. 交互收益
用户仅凭预览条底部的明暗分布，即可在指尖滑动过程中瞬间确认当前“哪一个窗口是焦点”，实现了无需抬头注视主屏幕即可完成精准窗口切换的直觉化体验。

### 2026-02-05：全方位布局支持与内存泄露深度治理

#### 1. 全方位 Dock 布局支持 (左/右/底)
- **方位感知算法**：通过 `DockPositionManager` 实时分析屏幕 `frame` 与 `visibleFrame` 的几何差异，动态识别 Dock 位于屏幕的左侧、右侧还是底部。
- **自适应弹出逻辑**：由于坐标系差异（CoreGraphics 与 AppKit 垂直翻转），重构了弹出位置计算公式。侧边 Dock 模式下预览条改为水平弹出，并实现与图标的垂直居中。
- **物理隔离保护**：通过 10px 的视觉避让与重构“安全走廊”逻辑，解决了侧边 Dock 上下滑动时鼠标易被错误锁死在旧预览框的交互痛点。

#### 2. 内存泄露专项治理 (Zero Leak)
- **引用计数修复**：针对 `CGEventTap` 回调中的内存堆积，将 `DockEventMonitor` 和 `HoverEventMonitor` 中的 `passRetained(event)` 全量修正为 `passUnretained(event)`。
- **性能收益**：彻底拦截了鼠标高频移动产生的引用计数泄露，确保软件在极致响应速度的同时，内存占用保持恒定。

#### 3. 视觉一致性与小窗布局优化
- **动态边界识别**：引入 `realDockThickness` 实时捕获 Dock 的像素级物理厚度，取代了硬编码的 100px 探测区。
- **布局分区优化**：
  - **底部紧贴模式**：由于底部系统标签带有“小箭头”，采用 0px 间距的紧贴模式以强制遮挡系统 UI。
  - **侧边呼吸模式**：由于侧面标签为平滑胶囊状，保留 10px 间距以维持视觉通透感。
- **识别算法增强**：在 `WindowThumbnailService` 中引入模糊匹配（Fuzzy Matching），显著提升了对非标准 UI 框架应用（如微信、Telegram）的窗口捕捉兼容性。

#### 4. 设置面板交互逻辑优化
- **联动禁用机制**：修复了“原位预览”开关的交互逻辑。现在该选项严格依赖于“子窗口独立收起/展开”的状态，当依赖项关闭时，原位预览会自动禁用并呈半透明状态，消除了设置逻辑中的歧义。

#### 5. 内存泄露深度治理 (V2.3)
- **缩略图缓存 LRU 机制**：针对 `WindowThumbnailService` 导致的 GB 级内存占用，实施了严格的**LRU (Least Recently Used) 淘汰策略**。缓存池上限设定为 50 张，超出后自动清理最久未使用的截图，将内存占用锁定在健康范围。
- **线程池防护 (Autoreleasepool)**：检查并修复了后台常驻线程 (`DockIconCacheManager`) 与高频 HID 事件回调 (`HoverEventMonitor`) 中的临时对象堆积问题。通过显式添加 `autoreleasepool`，确保了高频循环中的内存垃圾能被即时回收。

### 2026-02-08：静默启动逻辑与启动弹窗优化 (V5.25)

#### 1. 静默启动实现 (Silent Startup)
- **需求**：用户希望开机自启动时不要弹出设置窗口，仅在后台静默运行。
- **方案**：引入 `hasLaunchedBefore` 持久化标记。
- **逻辑**：
  - 在 `AppDelegate.applicationDidFinishLaunching` 中检查 `UserDefaults`。
  - 只有当 `hasLaunchedBefore` 为 `false` 时才调用 `showSettingsWindow()`。
  - 首次调用后立即将标记设为 `true`。
- **收益**：既保留了“首次安装有反馈”的引导流程，又解决了“开机频繁打扰”的用户痛点。

---

**文档版本**：2.3
**最后更新**：2026-02-08
