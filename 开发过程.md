# DockMinimize 开发过程总结文档

> 本文档详细记录了 DockMinimize 应用从零开始的完整开发过程，包含技术架构、核心实现、踩坑记录与最佳实践。供后续开发者或 AI 助手快速理解项目并避免重复踩坑。

---

## 一、项目概述

**应用名称**：DockMinimize  
**功能定位**：一款 macOS 菜单栏工具，通过监听 Dock 图标点击事件，实现"点击 Dock 图标隐藏和显示窗口"的功能。  
**技术栈**：Swift + SwiftUI + AppKit (Cocoa)  
**最低系统要求**：macOS 12.0+  
**架构类型**：支持 Universal Binary (arm64 + x86_64)

---

## 二、核心架构

### 2.1 文件结构

```
DockMinimize/
├── DockMinimize/                    # Xcode 项目目录
│   ├── DockMinimize.xcodeproj/      # Xcode 工程文件
│   ├── AppDelegate.swift            # 应用生命周期管理
│   ├── MenuBarController.swift      # 菜单栏图标与设置窗口控制
│   ├── SettingsManager.swift        # 设置管理（单例）
│   ├── SettingsView.swift           # SwiftUI 设置界面
│   ├── DockEventMonitor.swift       # Dock 事件监听核心逻辑
│   ├── AccessibilityManager.swift   # 辅助功能权限管理
│   ├── WindowManager.swift          # 窗口操作工具类
│   ├── DebugLogger.swift            # 调试日志工具
│   ├── Info.plist                   # 应用配置
│   ├── AppIcon.icns                 # 应用图标（永久存储）
│   └── Assets.xcassets/             # 资源目录
│       ├── AppIcon.appiconset/      # 应用图标源文件
│       └── MenuBarIcon.imageset/    # 菜单栏图标源文件 (menu.png)
├── build_dmg.sh                     # 当前架构 DMG 打包脚本
├── build_universal_dmg.sh           # 通用架构 DMG 打包脚本
└── DockMinimize.app/                # 编译产物（运行时生成）
```

### 2.2 核心类职责

| 类名 | 职责 |
|------|------|
| `AppDelegate` | 应用入口，初始化 MenuBarController，处理应用重新激活逻辑 |
| `MenuBarController` | 管理菜单栏图标、左键/右键交互、设置窗口的创建与显示 |
| `SettingsManager` | 单例模式，管理所有用户设置（操作模式、语言、开机启动等） |
| `SettingsView` | SwiftUI 视图，提供用户配置界面 |
| `DockEventMonitor` | 核心功能：监听 Dock 图标点击事件并执行相应操作 |
| `AccessibilityManager` | 检查和请求辅助功能权限 |

---

## 三、关键技术实现

### 3.1 菜单栏图标与交互 (MenuBarController)

**核心要点：**

1. **左右键分离**：
   - 左键点击：直接弹出设置面板（居中显示）
   - 右键点击：弹出上下文菜单（设置/退出）
   - 实现方式：通过 `button.sendAction(on: [.leftMouseUp, .rightMouseUp])` 监听不同事件

2. **窗口定位**：
   - 每次显示都调用 `window.center()` 确保居中
   - **禁止**使用 `setFrameAutosaveName`（会导致位置记忆，与预期不符）

3. **图标加载优先级**：
   ```swift
   // 1. 优先从 Resources 加载
   NSImage(contentsOf: Bundle.main.url(forResource: "menu_icon", withExtension: "png"))
   // 2. 其次从 Assets 加载
   NSImage(named: "MenuBarIcon")
   // 3. 兜底使用系统符号
   NSImage(systemSymbolName: "square.3.layers.3d.down.right")
   ```

4. **窗口生命周期**：
   - 设置 `window.isReleasedWhenClosed = false`，确保窗口关闭后不被销毁
   - 这能实现"秒开"效果，避免每次都重新创建窗口

### 3.2 多语言支持 (i18n)

**实现方案**：

```swift
// SettingsManager.swift
enum AppLanguage: String, CaseIterable {
    case english = "en"
    case simplifiedChinese = "zh-Hans"
}

func t(_ zh: String, _ en: String) -> String {
    return language == .simplifiedChinese ? zh : en
}
```

**使用方式**：
```swift
Text(settingsManager.t("设置", "Settings"))
```

**注意事项**：
- 语言切换需要发送通知 `.languageChanged`，菜单栏控制器需监听并刷新菜单
- 默认语言根据系统 `Locale.current.identifier` 自动判断

### 3.3 首次启动自动弹窗

在 `AppDelegate.applicationDidFinishLaunching` 中调用：
```swift
menuBarController?.showSettingsWindow()
```

这能让用户在首次打开应用时立即看到设置面板，确认软件已运行。

---

## 四、踩坑记录与解决方案

### 4.1 终端命令执行断连

**问题**：在 M3 Pro 上执行复杂的 Shell 命令链时，终端 PTY 连接频繁断开。

**原因**：
1. 使用 `#` 注释符号在命令行字符串内部会导致 zsh 解析错误
2. 过长的 `&&` 链式命令超过了某些环境的缓冲限制

**解决方案**：
- 拆分命令为多个独立的 `run_command` 调用
- 避免在命令字符串中使用 `#` 注释

### 4.2 图标显示异常

**问题**：应用图标或菜单栏图标不显示、显示透明、或显示旧版本。

**根因**：
1. 图标源文件未正确存入 `Assets.xcassets`
2. `Info.plist` 中 `CFBundleIconFile` 未正确指向 `AppIcon`
3. macOS 系统图标缓存未刷新

**解决方案**：
1. 将图标永久存入项目目录（`DockMinimize/AppIcon.icns` 和 `Assets.xcassets/MenuBarIcon.imageset/menu.png`）
2. 打包脚本中强制注入并执行 `plutil -replace CFBundleIconFile -string AppIcon`
3. 执行 `touch DockMinimize.app` 刷新系统认知

### 4.3 codesign 签名失败

**问题**：`DockMinimize.app: resource fork, Finder information, or similar detritus not allowed`

**原因**：文件包含 macOS 扩展属性（如通过 Finder 复制时附加的元数据）

**解决方案**：
在签名前执行：
```bash
xattr -cr "$APP_NAME.app"
```

### 4.4 设置窗口位置不一致

**问题**：设置面板每次打开位置不同，甚至"满屏乱跑"。

**原因**：
1. 使用了 `setFrameAutosaveName` 导致系统记忆了用户拖动的位置
2. 重复调用 `center()` 的时机不对

**解决方案**：
- 移除 `setFrameAutosaveName`
- 在每次 `showSettingsWindow` 时都调用 `window.center()`

### 4.5 右键菜单显示快捷键

**问题**：右键菜单显示了多余的快捷键提示（如 ⌘Q）

**解决方案**：
将 `keyEquivalent` 设置为空字符串：
```swift
NSMenuItem(title: "退出", action: #selector(NSApplication.terminate(_:)), keyEquivalent: "")
```

---

## 五、打包与发布

### 5.1 打包脚本

项目根目录下有两个打包脚本：

| 脚本 | 用途 |
|------|------|
| `build_dmg.sh` | 快速打包当前架构（适合开发测试） |
| `build_universal_dmg.sh` | 打包通用架构（支持 Intel + Apple Silicon，适合正式发布） |

### 5.2 打包流程关键步骤

1. **编译**：使用 `xcodebuild` 编译 Release 版本
2. **资源注入**：
   - 复制 `AppIcon.icns` 到 `Contents/Resources/`
   - 复制 `menu.png` 到 `Contents/Resources/menu_icon.png`
   - 更新 `Info.plist` 中的图标引用
3. **清理扩展属性**：`xattr -cr DockMinimize.app`
4. **签名**：`codesign --force --deep --sign - DockMinimize.app`
5. **生成 DMG**：使用 `hdiutil` 创建镜像

### 5.3 通用架构编译参数

```bash
xcodebuild ... ARCHS="arm64 x86_64" ONLY_ACTIVE_ARCH=NO
```

---

## 六、设置与权限

### 6.1 辅助功能权限

应用需要辅助功能权限才能监听 Dock 点击事件。

**检查权限**：
```swift
AXIsProcessTrusted()
```

**请求权限**：
```swift
let options = [kAXTrustedCheckOptionPrompt.takeUnretainedValue() as String: true]
AXIsProcessTrustedWithOptions(options as CFDictionary)
```

### 6.2 开机自动启动

使用 `ServiceManagement` 框架：
```swift
import ServiceManagement

// 注册
try SMAppService.mainApp.register()

// 取消注册
try SMAppService.mainApp.unregister()

// 检查状态
SMAppService.mainApp.status == .enabled
```

---

## 七、UI 设计规范

### 7.1 设置面板

- **尺寸**：320 x 460
- **样式**：无标题栏透明、可拖动、始终置顶 (`.floating`)
- **位置**：每次打开都居中显示

### 7.2 菜单栏图标

- **尺寸**：18 x 18 像素
- **格式**：PNG，设置 `isTemplate = true` 以适应深色/浅色模式

### 7.3 右键菜单

- **菜单项**：设置（齿轮图标）、退出（圆圈叉号图标）
- **无快捷键提示**：`keyEquivalent` 设为空

---

## 八、注意事项清单

1. **图标资源必须永久存入项目目录**，不要依赖外部临时文件
2. **菜单栏控制器必须继承 NSObject** 才能使用 `@objc` 方法
3. **窗口 center() 必须在每次显示时调用**，不要使用位置记忆
4. **打包前必须清理扩展属性** (`xattr -cr`)
5. **复杂命令拆分执行**，避免 PTY 断连
6. **语言切换需要发通知**，菜单栏需监听并刷新
7. **首次启动必须弹窗**，让用户知道软件已运行

---

## 九、后续开发建议

1. 如需修改图标，请同时更新 `Assets.xcassets` 和项目根目录的备份文件
2. 如需新增设置项，在 `SettingsManager` 中添加 `@Published` 属性并配置 `UserDefaults` 持久化
3. 如需调整窗口行为，请始终在 `MenuBarController.showSettingsWindow()` 中修改
4. 运行打包脚本前，建议先关闭正在运行的应用实例

---

## 十、悬停预览功能模块 (Hover Preview)

### 10.1 功能概述

在 Dock 图标上悬停时显示窗口预览缩略图，类似 Windows 任务栏的 Hover Preview 功能。

### 10.2 新增文件

| 文件 | 职责 |
|------|------|
| `ScreenCaptureManager.swift` | 屏幕录制权限管理、窗口截图 |
| `WindowThumbnailService.swift` | 获取应用窗口列表、缩略图生成与缓存 |
| `HoverEventMonitor.swift` | 全局 MouseMoved 事件监听、Dock 图标悬停检测 |
| `PreviewStateManager.swift` | 交互状态机（hidden/showing/peeking） |
| `PreviewBarView.swift` | 预览条主视图（SwiftUI） |
| `ThumbnailCardView.swift` | 单个缩略图卡片视图 |
| `PreviewBarController.swift` | 预览条窗口控制器，整合所有模块 |

### 10.3 核心状态机

```
hidden ──(悬停 Dock 0.1s)──> showing ──(悬停缩略图 0.3s)──> peeking
   ^                            │                             │
   └────────(鼠标移出)──────────┴─────────────────────────────┘
```

### 10.4 权限要求

- **辅助功能权限**：用于检测 Dock 图标和控制窗口
- **屏幕录制权限**：用于截取窗口缩略图

### 10.5 用户设置

在设置面板新增：
- 悬停预览开关（默认开启）
- 屏幕录制权限状态显示与授权引导

---

## 十一、 架构大版本迭代：Hover Preview 与状态机模式 (V5.9 - V5.13)

本阶段标志着 DockMinimize 从单一的“点击增强工具”升级为具备“Windows 风格悬停预览”的综合窗口管理软件。

### 11.1 悬停预览 (Hover Preview) 功能实现 (V5.9)

**需求来源**：用户希望在 Dock 图标上悬停 0.1秒后，显示该 App 所有窗口的实时缩略图，并支持水平滚动查看。

**技术实现路径：**
1. **触发逻辑 (`HoverEventMonitor`)**：
   - 监听全局 `kCGEventMouseMoved` 事件。
   - 实现了基于 `AXUIElement` 的 Dock 图标位置与 Bundle ID 提取逻辑。
   - 引入 0.1s 延迟消抖，避免快速划过 Dock 时频繁闪烁。

2. **UI 架构 (`PreviewBarController`)**：
   - 使用 `NSWindow` 创建无边框悬浮窗。
   - 内部嵌入 `SwiftUI` 视图 (`PreviewBarView`)。
   - 实现了水平滚动逻辑：
     - 如果窗口数量少（< 5个），自动居中。
     - 如果窗口数量多，开启水平滚动。
     - 渐变遮罩 (Fade Mask)：在滚动视图边缘添加渐变层，提示用户还有更多内容。

### 11.2 窗口截图 (Snapshot) 技术攻关

**核心挑战**：标准 API `CGWindowListCreateImage` 无法截取 **最小化** 状态的窗口（截取结果为空白或仅有阴影）。

**技术演进**：
1. **尝试一：公共 API**：失败，无法满足需求。
2. **尝试二：参考 DockDoor (开源项目)**：
   - 引入私有 API 桥接头文件 `PrivateApis.swift`。
   - 核心函数：`CGSHWCaptureWindowList` (来自 CoreGraphics 私有符号)。
   - **多级回退策略**：
     - 首选：`[.ignoreGlobalClipShape, .bestResolution]`（最佳质量）。
     - 备选：`[.ignoreGlobalClipShape, .nominalResolution]`（针对部分最小化窗口）。
     - 兜底：无 Flags（最原始截图）。

### 11.3 窗口过滤与匹配逻辑重构 (V5.10)

**痛点解决**：截图 API 返回了大量系统背景层、透明窗口或不可见辅助窗口。

**方案升级**：
1. **引入 DockDoor 过滤算法**：
   - 排除 `kCGWindowLayer != 0` 的非应用层口。
   - 排除 `kCGWindowAlpha == 0` 的完全透明窗口。
   - 排除 `kCGWindowOnScreen == false` 且非最小化的窗口。
2. **精准对象映射**：
   - 重构 `WindowInfo` 结构体，增加 `axElement: AXUIElement` 字段。
   - 使用 `_AXUIElementGetWindow` (私有 API) 将 Accessibility 对象与 CGWindowID 建立强绑定，替代了不可靠的 PID 遍历匹配。

### 11.4 交互体验优化：大图预览与状态机调优 (V5.11 - V5.13)

**交互问题**：用户反馈悬停缩略图时，直接“展开”原窗口体验非常突兀，且容易误操作。
**解决方案**：
1. **引入中心大图预览 (`LargePreviewView`)**：
   - 悬停缩略图时，不再触碰真实窗口。
   - 改为在屏幕中央弹出一个独立的 `LargePreviewWindow`，显示该窗口的高清截图。
2. **点击行为规范化**：
   - **单击展开**：利用保存的 `axElement` 调用系统级 `AXRaise` 动作。
   - **再次点击收回**：利用 `kAXMinimizedAttribute` 实现最小化。

### 11.5 存储架构：CacheManager 的引入

**背景**：为了解决重启后预览图丢失需要重新抓取导致 CPU 飙升的问题。
**方案**：
- 实现 `CacheManager`，将缩略图以 PNG 格式持久化到 `~/Documents/DockMinimize_Cache/`。
- 引入 **第三步权限 ("临时存储")**：在设置面板申请磁盘写入权限，合规访问非沙盒目录。
- **自动维护**：24小时过期清理 + 200MB 容量上限。

---


## 十二、UI 改版：沉浸式侧边栏与系统级质感 (V5.14)

### 12.1 系统级 "Liquid Glass" 效果 (macOS 13+)

**痛点**：原先使用 `.sidebar` material 结合 `HStack` 手写布局，导致侧边栏呈现“磨砂玻璃”效果，与现代 macOS 应用通透的“液态玻璃”质感不符。

**重构方案**：
1. **全面拥抱系统 API**：
   - 移除所有手动 `VisualEffectView` 背景设置。
   - 采用 `NavigationSplitView` + `.listStyle(.sidebar)`。
   - 这让系统能够自动接管侧边栏的材质渲染，完美呈现官方的半透明、通透光影效果。

2. **代码实现**：
   ```swift
   NavigationSplitView {
       List(SettingsTab.allCases, id: \.self, selection: $selectedTab) { ... }
       .navigationSplitViewColumnWidth(min: 180, ideal: 200, max: 220)
       // ...
   } detail: {
       contentView.background(Color(NSColor.windowBackgroundColor))
   }
   ```

### 12.2 视觉排版精修

**尺寸与间距调整：**
- **窗口瘦身**：整体尺寸缩减至 **700 x 480**，更加紧凑精致。
- **内容对齐**：内容页面的顶部 Padding 从 32 缩减至 **12**，确保标题“权限设置”与侧边栏选中项在视觉上水平对齐。
- **侧边栏宽度优化**：
  - 设置 `min: 180`，防止英文标签显示不全。
  - 设置 `max: 220`，防止用户过度拖拽导致布局失衡。

**细节打磨：**
- **退出按钮**：颜色调整为淡红色 (`.red.opacity(0.8)`)，在保持警示的同时不失优雅。
- **对齐修正**：统一常规设置中所有图标容器宽度为 **30px**，解决因图标光栅尺寸不同导致的未对齐问题。
- **左对齐修正**：操作模式下的提示卡片文字强制左对齐，消除居中显示的违和感。

---

## 十三、 深度交互优化与兼容性方案 (V5.15 - V5.18)

本阶段解决了多个长期困扰用户的交互痛点，并引入了“应用黑名单”作为通用兼容性方案。

### 13.1 应用黑名单 (Blacklist) 与 UI 美化 (V5.15)

**背景**：部分特殊应用（如“贴边隐藏”软件、浮动工具栏）与插件的事件拦截机制冲突，导致无法通过点击 Dock 图标正常激活。

**解决方案**：
1. **黑名单机制**：
   - 允许用户手动将特定应用加入黑名单。
   - **全面避让**：对于黑名单应用，插件不仅不拦截事件，而且不生成预览图、不调用任何相关 Accessibility API，实现“彻底透明”。
2. **UI 优化**：
   - **左对齐布局**：将黑名单设置界面的所有元素调整为左对齐，保持软件整体审美一致。
   - **条件化显示**：当黑名单为空时，隐藏中间的列表容器和“暂无记录”提示，仅显示警告文字和添加按钮，视觉效果更清爽。

### 13.2 悬停性能与“丝滑”响应 (V5.16)

**优化点**：
- **瞬发感应**：将 Dock 图标的悬停识别延迟从原先的 50ms 压缩至 **20ms**。
- **效果**：用户在大范围、快速地左右滑动 Dock 栏时，预览条会以“近乎零延迟”的速度紧随鼠标切换，不再有明显的脱节感。

### 13.3 彻底修复“小窗不消失”与“废纸篓冲突” (V5.17)

**Bug 描述**：当鼠标移向废纸篓或从 Dock 边缘滑出到桌面时，预览条会卡在屏幕上不消失；点击桌面也无法强制其关闭。

**解决方案**：
1. **精准区域判定**：移除了模糊的 `inDock` 全区域检查。现在插件会准确判断鼠标是否仍在特定的 App 图标上，一旦滑入“废纸篓”这类不产生预览的区域，立即触发消失。
2. **全局点击监听 (Global Click Monitor)**：
   - 引入系统级监听器：`NSEvent.addGlobalMonitorForEvents`。
   - **兜底策略**：只要用户点击了桌面、浏览器或其他任何非预览区域，预览条会接收到指令强制自我毁灭，绝不留恋。
3. **交互稳定性防护**：
   - 增加了 **Dock 200ms** 和 **预览条 300ms** 的移出缓冲区，防止因快速操作或手抖导致的预览窗闪退。

### 13.4 多窗口“点两次才弹完”的深度根治 (V5.18)

**问题根源**：
- 之前逻辑过于依赖内存缓存（记录谁被最小化了），导致状态识别不准。
- 且在应用处于后台时，将点击权交还给系统 Dock，而系统 Dock 默认往往只弹出第一个窗口。

**核心修复方案**：
1. **实时状态扫描 (Real-time AX Scan)**：
   - 彻底废弃内存缓存。每次点击 Dock 图标时，都会实时扫描该应用的所有窗口。
   - **判定逻辑**：只要有一个窗口是最小化的，点击的目标就是“**一次性恢复所有窗口**”。
2. **全面接管后台点击**：
   - 插件不再放行后台应用的点击。只要应用在运行且不在黑名单中，我们就会拦截点击动作。
   - 手动接管“从背景回前台”的转换过程，确保第一下点击就强制执行 `restoreAllWindows`，实现“一键全开”。

---

## 十四、 性能与稳定性终极闭环优化 (V5.19 - V5.21)

本阶段通过重构底层交互锁机制，彻底解决了单窗口操作的“不丝滑”感以及多窗口操作下的系统级崩溃问题。

### 14.1 单窗口“零拦截”与极限响应 (Zero-Interception)

**痛点**：为了防崩溃引入的 `isTransitioning` 状态锁在单窗口下显得过于臃肿，导致用户快速连点时出现“点击落空”。

**优化方案**：
1. **拦截豁免**：在 `WindowManager` 中调整判定顺序。针对单窗口应用，**直接跳过**拦截检查。
2. **效果**：无论点击多快，哪怕动画在半途中，系统也会立刻响应下一次指令，实现物理级的“无感”交互。
3. **极速释放**：将单窗口的锁定延迟压缩至 **50ms**（仅用于硬件消抖），基本等同于零延迟。

### 14.2 物理级“阶梯锁定”替代脆弱轮询 (Fixed-Time Safety)

**技术重构**：
- **废弃轮询**：彻底删除基于 `AXUIElement` 的画面稳定性监测逻辑。理由是 Finder 等系统 App 在动画中会产生大量“窗口幽灵状态”，导致轮询陷入死锁。
- **阶梯延时策略**：基于窗口数量设定固定的“呼吸时间”：
    - **1 个窗口**：0.05s 解锁。
    - **2-3 个窗口**：0.35s 解锁（精准匹配 macOS 动画时长）。
    - **> 3 个窗口**：0.4s 解锁（隐藏模式专属时间）。
- **收益**：保证了 100% 的响应成功率，彻底杜绝了“图标卡死不响应”的现象。

### 14.3 智能双模切换 (Smart Hybrid Mode)

**核心防御策略**：
- **自动判定**：当检测到同 App 窗口数 **> 3 个** 时，系统会自动从“最小化”转向**“隐藏”模式**。
- **避坑逻辑**：多窗口同时执行最小化动画是 macOS 底层渲染崩溃的高效触发点。隐藏模式瞬间完成且不触发系统缩放动画，从算法层面绕过了崩溃路径。

### 14.4 SwiftUI 渲染稳定性：ViewModel 复用与原子刷新

**崩溃修复**：
- **VM 复用**：如果用户在同一 App 的图标上快速反复悬停，不再重建整个 View 树，而是复用现有的 `ViewModel` 仅更新数据。
- **原子刷新**：在切换不同 App 的预览图时，强制先执行 `window.contentView = nil` 进行彻底卸载，再挂载新视图，防止因视图复用导致的内存竞态崩溃。
- **无条件消失**：修正了 `hidePreviewBar` 的逻辑，确保鼠标一旦移出，预览窗口**无条件**撤离屏幕，不再受窗口锁定状态的影响。

---

**文档版本**：1.7  
**最后更新**：2026-02-03

---

## 十五、 动画与交互逻辑精调 (V5.22+)

本阶段着重打磨“微交互”体验，解决了用户关于点击反馈逻辑的细腻需求，并确保了 Dock 图标点击与预览条交互的一致性。

### 15.1 "上抬" (Lift Up) 动画与逻辑重塑

**需求背景**：用户反馈原先简单的“点击即变灰”逻辑与直觉不符。当一个窗口虽然已显示但被其他窗口遮挡时，点击它应该是“置顶”而非“最小化”。

**核心逻辑重构**：
1. **区分三种状态动作**：
   - **收缩 (Shrink)**：`Active -> Minimized` (变灰)。只有当窗口已经在前台且完全活跃时触发。
   - **伸展 (Expand)**：`Hidden -> Visible` (变蓝)。当窗口从最小化状态唤醒时触发。
   - **上抬 (Bounce)**：`Obscured -> Active` (蓝色保持，上跳一下)。当窗口已在屏幕上但非最前，或仅仅被点击置顶时触发。

2. **后端驱动 UI 真相 (Backend-Driven UI Truth)**：
   - 废弃了 View 层简单的 `.toggle()` 预测。
   - 重构 `PreviewStateManager.clickThumbnail`，使其返回准确的布尔值结果 (`didMinimize: Bool`)。
   - View 层先调用后端，拿到准确结果后，结合点击前的状态 (`wasHidden`)，精准决定播放哪种动画：
     ```swift
     if didMinimize {
         // 执行收缩动画 (Shrink)
     } else {
         if wasHidden {
             // 执行伸展动画 (Expand) - 严禁 Bounce
         } else {
             // 执行上抬动画 (Bounce) - 仅在此场景触发
         }
     }
     ```

### 15.2 Dock 图标点击与预览条的完全同步

**痛点**：用户点击 Dock 图标（实体 App 图标）进行操作时，预览条的状态没有即时反馈，导致视觉割裂。

**解决方案**：
1. **事件广播机制**：
   - 在 `DockEventMonitor` 中，当拦截并处理点击事件后，立即广播 `DockIconClicked` 通知，携带 `action` 上下文 ("activate" 或 "toggle")。
   
2. **乐观 UI 同步**：
   - `PreviewBarViewModel` 监听该通知。
   - 当接收到通知时，立即对当前预览条以“乐观更新”的方式应用动画，无需等待系统状态轮询。
   - 实现了逻辑复用：Dock 图标点击现在能触发与点击缩略图完全一致的 Shrink/Expand/Bounce 动画效果，体验高度统一。
